// vale-native-bridge.js
// Purpose: Attempt to load a vale-native WASM build (produced by wasm-pack) and expose a uniform lint API.
// Fallback: Use provided JS substitution rules if WASM (or API) unavailable.

let wasmReady = false;
let wasmLintFn = null;
let initError = null;

// Configuration assumptions:
// After running `wasm-pack build --target web --release` in the vale-native repo, copy the generated `pkg/` folder
// into `chrome-extension/`. Suppose crate name = `vale_native`; wasm-pack outputs:
//   pkg/vale_native.js
//   pkg/vale_native_bg.wasm
// This bridge will dynamically import the JS module and call an assumed exported function:
//   lint_text(text, rulesJson) -> stringified JSON diagnostics OR object/array.
// If the actual API differs, adapt `initializeWasm` accordingly.

export async function initializeWasm(rulesObject) {
  if (wasmReady || initError) return { wasmReady, initError };
  try {
    // Dynamically check for presence of the wasm module by attempting fetch of the .wasm asset first.
    const wasmUrl = chrome.runtime.getURL('pkg/vale_native_bg.wasm');
    const headResp = await fetch(wasmUrl, { method: 'HEAD' });
    if (!headResp.ok) throw new Error('WASM file not found (HEAD check failed)');

    // Import the JS glue module (ESM) generated by wasm-pack.
    const moduleUrl = chrome.runtime.getURL('pkg/vale_native.js');
    const mod = await import(moduleUrl);
    // wasm-pack modules usually export a default init or an initSync; call default with explicit URL to keep MV3 happy.
    if (typeof mod.default === 'function') {
      await mod.default(wasmUrl);
    }

    // Heuristic: find a plausible lint function. Adjust if actual API known.
    if (typeof mod.lint_text === 'function') {
      wasmLintFn = (text) => mod.lint_text(text, JSON.stringify(rulesObject));
    } else if (typeof mod.lint === 'function') {
      wasmLintFn = (text) => mod.lint(text, rulesObject);
    } else {
      throw new Error('No lint function exported (expected lint_text or lint)');
    }
    wasmReady = true;
  } catch (e) {
    initError = e;
  console.warn('[vale-native-bridge] WASM init failed, falling back to JS rules:', e); // keep raw console early init
  }
  return { wasmReady, initError };
}

export function lintWithWasm(text) {
  if (!wasmReady || !wasmLintFn) return null; // caller falls back
  try {
    const out = wasmLintFn(text);
    if (out == null) return [];
    if (Array.isArray(out)) { out.forEach(d=>d.__wasm=true); return out; }
    if (typeof out === 'string') {
      try { const arr = JSON.parse(out); if (Array.isArray(arr)) arr.forEach(d=>d.__wasm=true); return arr; } catch { return []; }
    }
    const diagArr = out.diagnostics || out.results || [];
    if (Array.isArray(diagArr)) diagArr.forEach(d=>d.__wasm=true);
    return diagArr;
  } catch (e) {
  console.warn('[vale-native-bridge] lint failed, reverting to fallback', e);
    return null;
  }
}
