#!/usr/bin/env node
// Build script for Chrome extension: copies source, gathers rule YAML files, generates rules-index.js
// and expands manifest web_accessible_resources to include all rule files + wasm if present.
import fs from 'fs';
import path from 'path';
import { fileURLToPath } from 'url';
import zlib from 'zlib';

const __filename = fileURLToPath(import.meta.url);
const __dirname = path.dirname(__filename);
const repoRoot = path.resolve(__dirname, '..');
const extSrc = path.join(repoRoot, 'chrome-extension');
const rulesSrc = path.join(repoRoot, '.vale', 'styles', 'Sitecore');
const distRoot = path.join(repoRoot, 'dist');
const distExt = path.join(distRoot, 'extension');

const args = process.argv.slice(2);
const doClean = args.includes('--clean');
const doRebuild = args.includes('--rebuild');
const doZip = args.includes('--zip');
const domainArg = args.find(a => a.startsWith('--domain='));
const domains = domainArg ? [domainArg.split('=')[1].replace(/"/g,'').replace(/\/$/,'') + '/*'] : ['<all_urls>'];

if (doClean || doRebuild) {
  fs.rmSync(distRoot, { recursive: true, force: true });
  console.log('Cleaned dist/');
  // If only cleaning (and not rebuilding), exit early.
  if (!doRebuild && doClean && args.length === 1) process.exit(0);
}

fs.mkdirSync(distExt, { recursive: true });

function copyRecursive(src, dest, filter) {
  if (!fs.existsSync(src)) return;
  const stat = fs.statSync(src);
  if (stat.isDirectory()) {
    fs.mkdirSync(dest, { recursive: true });
    for (const entry of fs.readdirSync(src)) {
      if (filter && !filter(entry, src)) continue;
      copyRecursive(path.join(src, entry), path.join(dest, entry), filter);
    }
  } else {
    fs.copyFileSync(src, dest);
  }
}

// Copy extension source except old rules directory (we'll rebuild)
copyRecursive(extSrc, distExt, (entry, srcDir) => {
  if (entry === 'rules') return false; // skip, regenerate
  return true;
});

// Gather rule files
const ruleFiles = fs.existsSync(rulesSrc) ? fs.readdirSync(rulesSrc).filter(f => f.endsWith('.yml')) : [];
const rulesDistDir = path.join(distExt, 'rules', 'Sitecore');
fs.mkdirSync(rulesDistDir, { recursive: true });
for (const f of ruleFiles) fs.copyFileSync(path.join(rulesSrc, f), path.join(rulesDistDir, f));

// Generate rules-index.js
const rulesIndexPath = path.join(distExt, 'rules-index.js');
const ruleArray = ruleFiles.map(f => 'Sitecore/' + f);
fs.writeFileSync(rulesIndexPath, `// Auto-generated by build-extension.mjs\nexport const RULE_FILES = ${JSON.stringify(ruleArray, null, 2)};\n`);

// Rewrite manifest with full web_accessible_resources list
const manifestPath = path.join(extSrc, 'manifest.json');
const manifest = JSON.parse(fs.readFileSync(manifestPath, 'utf8'));
// Override matches if domain(s) specified
if (domains[0] !== '<all_urls>') {
  if (manifest.content_scripts) {
    manifest.content_scripts.forEach(cs => { cs.matches = domains; });
  }
}
const wasmFiles = [];
const pkgDir = path.join(extSrc, 'pkg');
if (fs.existsSync(pkgDir)) {
  for (const f of fs.readdirSync(pkgDir)) {
    if (f.endsWith('.wasm')) wasmFiles.push('pkg/' + f);
  }
  // Copy pkg directory
  copyRecursive(pkgDir, path.join(distExt, 'pkg'));
}
manifest.web_accessible_resources = [
  {
    resources: [
      ...ruleArray.map(r => 'rules/' + r),
      ...wasmFiles
    ],
    matches: domains
  }
];
fs.writeFileSync(path.join(distExt, 'manifest.json'), JSON.stringify(manifest, null, 2));

// Optional zip packaging
if (doZip) {
  const zipName = `extension-${manifest.version}.zip`;
  // Simple naive zip via JS not trivial; rely on system zip if available.
  // We'll just note next steps instead of implementing streaming zip here to keep script dependency-free.
  console.log(`Run: powershell Compress-Archive -Path \"${distExt}/*\" -DestinationPath ${zipName}`);
}

console.log(`Built extension with ${ruleFiles.length} rule files.`);
