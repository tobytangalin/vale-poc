#!/usr/bin/env node
// Build script for Chrome extension: copies source, gathers rule YAML files, generates rules-index.js
// and expands manifest web_accessible_resources to include all rule files + wasm if present.
import fs from 'fs';
import path from 'path';
import { fileURLToPath } from 'url';
import zlib from 'zlib'; // (unused now, retained in case future compression enhancements needed)
import { execSync } from 'child_process';

const __filename = fileURLToPath(import.meta.url);
const __dirname = path.dirname(__filename);
const repoRoot = path.resolve(__dirname, '..');
const extSrc = path.join(repoRoot, 'chrome-extension');
const rulesSrc = path.join(repoRoot, '.vale', 'styles', 'Sitecore');
const distRoot = path.join(repoRoot, 'dist');
const distExt = path.join(distRoot, 'extension');

const args = process.argv.slice(2);
const doClean = args.includes('--clean');
const doRebuild = args.includes('--rebuild');
// Always produce a zip unless explicitly disabled with --no-zip
const disableZip = args.includes('--no-zip');
const domainArg = args.find(a => a.startsWith('--domain='));
const domains = domainArg ? [domainArg.split('=')[1].replace(/"/g,'').replace(/\/$/,'') + '/*'] : ['<all_urls>'];

if (doClean || doRebuild) {
  fs.rmSync(distRoot, { recursive: true, force: true });
  console.log('Cleaned dist/');
  // If only cleaning (and not rebuilding), exit early.
  if (!doRebuild && doClean && args.length === 1) process.exit(0);
}

fs.mkdirSync(distExt, { recursive: true });

function copyRecursive(src, dest, filter) {
  if (!fs.existsSync(src)) return;
  const stat = fs.statSync(src);
  if (stat.isDirectory()) {
    fs.mkdirSync(dest, { recursive: true });
    for (const entry of fs.readdirSync(src)) {
      if (filter && !filter(entry, src)) continue;
      copyRecursive(path.join(src, entry), path.join(dest, entry), filter);
    }
  } else {
    fs.copyFileSync(src, dest);
  }
}

// Copy extension source except old rules directory (we'll rebuild)
copyRecursive(extSrc, distExt, (entry, srcDir) => {
  if (entry === 'rules') return false; // skip, regenerate
  return true;
});

// Gather rule files
const ruleFiles = fs.existsSync(rulesSrc) ? fs.readdirSync(rulesSrc).filter(f => f.endsWith('.yml')) : [];
const rulesDistDir = path.join(distExt, 'rules', 'Sitecore');
fs.mkdirSync(rulesDistDir, { recursive: true });
for (const f of ruleFiles) fs.copyFileSync(path.join(rulesSrc, f), path.join(rulesDistDir, f));

// Generate rules-index.js
const rulesIndexPath = path.join(distExt, 'rules-index.js');
const ruleArray = ruleFiles.map(f => 'Sitecore/' + f);
fs.writeFileSync(rulesIndexPath, `// Auto-generated by build-extension.mjs\nexport const RULE_FILES = ${JSON.stringify(ruleArray, null, 2)};\n`);

// Rewrite manifest with full web_accessible_resources list
const manifestPath = path.join(extSrc, 'manifest.json');
const manifest = JSON.parse(fs.readFileSync(manifestPath, 'utf8'));
// Override matches if domain(s) specified
if (domains[0] !== '<all_urls>') {
  if (manifest.content_scripts) {
    manifest.content_scripts.forEach(cs => { cs.matches = domains; });
  }
}
const wasmFiles = [];
// Locate wasm pkg artifacts: prefer chrome-extension/pkg, else fallback to vale-wasm/pkg (produced by wasm-pack)
let pkgDir = path.join(extSrc, 'pkg');
if (!fs.existsSync(pkgDir)) {
  const alt = path.join(repoRoot, 'vale-wasm', 'pkg');
  if (fs.existsSync(alt)) pkgDir = alt;
}
if (fs.existsSync(pkgDir)) {
  for (const f of fs.readdirSync(pkgDir)) {
    if (f.endsWith('.wasm')) wasmFiles.push('pkg/' + f);
  }
  copyRecursive(pkgDir, path.join(distExt, 'pkg'));
} else {
  console.warn('No WASM pkg directory found; build will fallback to JS rules only.');
}
manifest.web_accessible_resources = [
  {
    resources: [
      ...ruleArray.map(r => 'rules/' + r),
      ...wasmFiles
    ],
    matches: domains
  }
];
fs.writeFileSync(path.join(distExt, 'manifest.json'), JSON.stringify(manifest, null, 2));

// Zip packaging (auto unless --no-zip)
let zipCreated = false;
if (!disableZip) {
  const zipName = `extension-${manifest.version}.zip`;
  const zipPath = path.join(distRoot, zipName);
  try { if (fs.existsSync(zipPath)) fs.rmSync(zipPath); } catch {}
  try {
    if (process.platform === 'win32') {
      // Use PowerShell Compress-Archive for Windows
      const psCmd = `Compress-Archive -Path '${distExt.replace(/'/g,"''")}\\*' -DestinationPath '${zipPath.replace(/'/g,"''")}' -Force`;
      execSync(`powershell -NoLogo -NoProfile -Command "${psCmd}"`, { stdio: 'inherit' });
      zipCreated = fs.existsSync(zipPath);
    } else {
      // Attempt to use `zip` CLI on *nix systems
      try {
        execSync(`zip -r -q '${zipPath.replace(/'/g,"'\\''")}' .`, { cwd: distExt, stdio: 'inherit', shell: '/bin/bash' });
        zipCreated = fs.existsSync(zipPath);
      } catch (e) {
        console.warn('zip command not available; skipping archive creation.');
      }
    }
  } catch (e) {
    console.warn('Failed to create zip archive:', e.message);
  }
  if (zipCreated) {
    console.log(`Created ${zipPath}`);
  } else if (!disableZip) {
    console.log('Zip archive not created (see warnings above).');
  }
}

console.log(`Built extension with ${ruleFiles.length} rule files.${zipCreated ? ' (zip packaged)' : ''}`);
